* Git

** [[https://backlog.com/git-tutorial/tw/][連猴子都能懂的Git入門指南]]

*** 初始設定

Git的設定會被記錄在用戶的目錄首頁下的.gitconfig檔案裡。

#+begin_src

$ git config --global user.name "<使用者名字>"

$ git config --global user.email "<電子信箱>"

#+end_src

可以為Git的命令設定別名，例如：「checkout」可以省略為「co」來執行。

#+begin_src

$ git config --global alias.co checkout

#+end_src

在Windows使用主控台（Git Bash）的話，含有中文的檔名會顯示為 "\346\226\260\350\246..."添加以下的設定，讓含有中文的檔名可以正確顯示。

#+begin_src

$ git config --global core.quotepath off

#+end_src

在提交訊息時要使用中文的話，不要使用 -m 參數，要用外部編輯器來輸入

#+begin_src

git config --global core.editor "emacs"

#+end_src


*** 新建數據庫

#+begin_src

$ mkdir tutorial-bare

$ cd tutorial-bare

$ git --bare init

#+end_src

#+begin_src

$ cd ..

$ mkdir tutorial

$ git clone tutorial-bare tutorial

$ cd tutorial
#+end_src

*** 提交檔案

首先在tutorial目錄裡新添一個名為「sample.txt」的文字檔案。請在檔案裡輸入以下的內容：

連猴子都懂的Git命令

#+begin_src

$ echo "連猴子都懂的Git命令" > sample.txt

#+end_src

在Git管理之下的目錄，可以使用status命令確認工作目錄與索引的狀態喔。

#+begin_src

$ git status

#+end_src

執行status命令確認tutorial目錄的狀態。

#+begin_src

$ git status
# On branch master
#
# Initial commit
#
# Untracked files:
#   (use "git add <file>..." to include in what will be committed)
#
#     sample.txt
nothing added to commit but untracked files present (use "git add" to track)

#+end_src

要將檔案加入到索引，可以使用add <file>命令。<file>是指向要加入索引的檔案。若要指向多個檔案，可用空白鍵將檔案們分開。

#+begin_src

$ git add sample.txt
$ git status
# On branch master
#
# Initial commit
#
# Changes to be committed:
#   (use "git rm --cached <file>..." to unstage)
#
#     new file:   sample.txt
#

#+end_src

#+begin_src

$ git commit -m "first commit"
[master (root-commit) 116a286] first commit
 0 files changed, 0 insertions(+), 0 deletions(-)
 create mode 100644 sample.txt

$ git status
# On branch master
nothing to commit (working directory clean)

#+end_src

#+begin_src

$ git log
commit ac56e474afbbe1eab9ebce5b3ab48ac4c73ad60e
Author: eguchi <eguchi@nulab.co.jp>
Date:   Thu Jul 12 18:00:21 2012 +0900

    first commit

#+end_src

安裝git的同時也會安裝gitk工具。可以用圖形化介面確認歷史提交記錄。

#+begin_src

$ gitk

#+end_src

#+begin_src
#+end_src

#+begin_src
#+end_src

#+begin_src
#+end_src

#+begin_src
#+end_src


** 為你自己學 Git

*** 使用者設定

#+BEGIN_SRC bash

$ git config --global user.name "Eddie Kao"

$ git config --global user.email "eddie@5xruby.tw"

$ git config --list
user.name=Eddie Kao
user.email=eddie@5xruby.tw
#+END_SRC

*** 設定檔的位置
檔案: ~/.gitconfig

*** 【狀況題】可以每個專案設定不同的作者嗎?

#+BEGIN_SRC bash

$ git config --local user.name Sherly

$ git config --local user.email sherly@5xruby.tw

#+END_SRC

*** 更換編輯器
#+BEGIN_SRC bash

$ git config --global core.editor emacs

#+END_SRC

*** Git 裡設定一些「縮寫」

#+BEGIN_SRC bash

$ git config --global alias.co checkout

$ git config --global alias.br branch

$ git config --global alias.st status

#+END_SRC

可以再加一些參數進去 ex: git log --oneline --graph
#+BEGIN_SRC bash

$ git config --global alias.l "log --oneline --graph"

$ git config --global alias.ls 'log --graph --pretty=format:"%h <%an> %ar %s"'

$ git log --oneline --graph

$ git log --graph --pretty=format:"%h <%an> %ar %s"

#+END_SRC

*** 新增、初始 Repository

#+BEGIN_SRC bash

$ mkdir git-practice# 建立 git-practice 目錄

$ cd git-practice# 切換至 git-practice 目錄

$ git init# 初始化這個目錄,讓 Git 對這個目錄開始進行版控
Initialized empty Git repository in /private/tmp/git-practice/.git/

#+END_SRC

#+BEGIN_SRC bash

$ git status
On branch master
Initial commit
nothing to commit (create/copy files and use "git add" to track)

#+END_SRC

#+BEGIN_SRC bash

$ echo "hello, git" > welcome.html

$ git status
On branch master

No commits yet

Untracked files:
  (use "git add <file>..." to include in what will be committed)
	welcome.html

nothing added to commit but untracked files present (use "git add" to track)

#+END_SRC

一次只加一個檔案

#+BEGIN_SRC bash

$ git add welcome.html

$ git status
On branch master

No commits yet

Changes to be committed:
  (use "git rm --cached <file>..." to unstage)
	new file:   welcome.html

#+END_SRC

可以使用萬用字元,可把所有附檔名是 html 的檔案全部都加到暫存區。

#+BEGIN_SRC bash

$ git add *.html

#+END_SRC

如果想要一口氣把全部的檔案加到暫存區,可直接使用 --all 參數:

#+BEGIN_SRC bash

$ git add --all

#+END_SRC

*** 【狀況題】如果在git add之後又修改了那個檔案的內容?

1. 你新增了一個檔案叫做 abc.txt 。
2. 然後,執行 git add abc.txt 把檔案加至暫存區。
3. 接著編輯 abc.txt 檔案。

#+BEGIN_SRC bash

$ git status
On branch master
Changes to be committed:
	(use "git reset HEAD <file>..." to unstage)

		new file:	abc.txt

Changes not staged for commit:
	(use "git add <file>..." to update what will be committed)
	(use "git checkout -- <file>..." to discard changes in working directory)

		modified:	abc.txt

#+END_SRC

*** 【冷知識】"--all" 跟 "." 參數有什麼不一樣?
1. Git 版本
在 git 1.x版的時候

| 使用參數 | 新增檔案 | 修改檔案 | 刪除檔案 |
| --all    | O        | O        | O        |
| .        | O        | O        | X        |

在 git 2.x版的時候

| 使用參數 | 新增檔案 | 修改檔案 | 刪除檔案 |
| --all    | O        | O        | O        |
| .        | O        | O        | O        |

2. 執行指令時候的目錄位置
git add . 這個指令會把目前當下這個目錄,以及它的子目錄、子子目錄、子子子目
錄...裡的異動全部加到暫存區,但在這個目錄的以外的就不歸它管了。

git add --all 指令
就沒這個問題,這個指令不管在專案的哪一層目錄執行,效果都是一樣的,在這個專案裡所有
的異動都會被加至暫存區。

答案會跟所使用的 Git 版本不同以及執行指令時的目錄而有所差異。

*** 把暫存區的內容提交到倉庫裡存檔

#+BEGIN_SRC bash

$ git commit -m "init commit"
[master (root-commit) dfccf0c] init commit
 1 file changed, 1 insertion(+)
 create mode 100644 welcome.html

#+END_SRC

*** 【冷知識】一定要有東⻄才能 Commit 嗎?

只要加上 --allow-empty 參數,沒東⻄也是可以 Commit 的:

#+BEGIN_SRC bash

$ git commit --allow-empty -m "空的"
[master 76a5b84] 空的

$ git commit --allow-empty -m "空的"
[master f4f568c] 空的

$ git commit --allow-empty -m "空的"
[master 7653117] 空的

#+END_SRC

*** 工作區、暫存區與儲存庫

1. git add 指令把檔案從工作目錄移至暫存區(或索引)。
2. git commit 指令把暫存區的內容移至儲存庫。

**** 一定要二段式嗎?

#+BEGIN_SRC bash

$ git commit -a -m "update content"

#+END_SRC

*** 檢視紀錄

#+BEGIN_SRC bash

$ git log
commit 82603ed32d877a1cc1c022ed48d2c69b2bc892cd (HEAD -> master)
Author: Ray Kuo <ray20140811@gmail.com>
Date:   Sat Sep 17 01:38:26 2022 +0800

    create index page

commit 36f407ffdf5d63a3b5cdd36d92c3e665033b1aa4
Author: Ray Kuo <ray20140811@gmail.com>
Date:   Fri Sep 16 16:58:21 2022 +0800

    init commit

#+END_SRC

*** git log參數
#+BEGIN_SRC bash

$ git log --oneline --graph
\* 82603ed (HEAD -> master) create index page
\* 36f407f init commit

#+END_SRC

*** 【狀況題】我想要找某個人或某些人的 Commit...

**** 找一位叫做 Sherly 的作者的 Commit

#+BEGIN_SRC bash

$ git log --oneline --author="Sherly"
930feb3 add pig
51d54ff add lion and tiger

#+END_SRC

**** 可以用|來查詢兩個人的紀錄

#+BEGIN_SRC bash

$ git log --oneline --author="Sherly\|Eddie"

#+END_SRC

*** 【狀況題】我想要找 Commit 訊息裡面有在罵髒話的

#+BEGIN_SRC bash

$ git log --oneline --grep="WTF"

#+END_SRC

#+BEGIN_SRC bash
#+END_SRC


** 你知道的 Git 和我知道的是同一件事嗎？
   https://www.youtube.com/watch?v=j72-2ktvZV4


** 你知道 Git 是怎麼一回事嗎
   https://www.youtube.com/watch?v=LgTf7m5B0xA
   - git add . 和 git add --all 這兩個指令有什麽不一樣？

   在 git 1.x版的時候
   | 使用參數 | 新增檔案 | 修改檔案 | 刪除檔案 |
   | -------  | -------  | -------  | ------   |
   | --all    | O        | O        | O        |
   | .        | O        | O        | X        |

   在 git 2.x版的時候
   | 使用參數 | 新增檔案 | 修改檔案 | 刪除檔案 |
   | -------- | -------- | -------- | -------- |
   | --all    | O        | O        | O        |
   | .        | O        | O        | O        |

   git add --all指令不管在專案的哪一層目錄執行都有效果


#+BEGIN_SRC bash
#+END_SRC

#+BEGIN_SRC bash
#+END_SRC


* Emacs

** Emacs筆記

| M-g g | goto-line     | 跳到指定行號      |
| M-d   | kill-word     | delete one word   |
| C-w   | kill-region   | delete one line   |
| M-w   | easy-kill     | copy              |
| C-y   | yank          | paste             |
| M-%   | query-replace | query and replace |


** [[https://orgmode.org][Org Mode]]


** [[https://www.cnblogs.com/Open_Source/archive/2011/07/17/2108747.html][Org-mode 简明手册]]


* rails

** Ruby on Rails自習手冊

*** 5-2 Active Record

| 物件導向         | 關聯式資料庫 |
|------------------+--------------|
| 類別 (class)     | 表 (table)   |
| 物件 (object)    | 列 (row)     |
| 屬性 (attribute) | 欄 (column)  |

**** 5-2-1 命名慣例

| 物件導向   | 關聯式資料庫                          |
|------------+---------------------------------------|
| 資料表     | 複數單字、蛇形命名法，例如 book_clubs |
| Model 類別 | 單數單字、駱駝命名法，例如 BookClub   |

| 類別     | 資料表     |
|----------+------------|
| Post     | posts      |
| LineItem | line_items |
| Deer     | deers      |
| Mouse    | mice       |
| Person   | people     |


**** 5-2-2 rails dbconsole
#+begin_src bash
$ bin/rails dbconsole
#+end_src

#+begin_src SQL
CREATE TABLE posts(
  id INTEGER PRIMARY KEY,
  title TEXT,
  content TEXT
);
#+end_src

#+begin_src ruby
# app/models/post.rb
class Post < ActiveRecord::Base
end
#+end_src


**** 5-2-3 rails console

#+begin_src bash
$ bin/rails console
Loading development environment (Rails 7.0.4)
3.1.2 :001 > Post.create title: 'hello', content: 'world'
=> #<Post id: 1, title: "hello", content: "world">
#+end_src

#+begin_src bash
$ bin/rails dbconsole
sqlite> select * from posts;
1|hello|world
#+end_src

#+begin_src bash
$ bin/rails console
Loading development environment (Rails 7.0.4)
3.1.2 :001 > Post.count
 => 1
3.1.2 :002 > post = Post.find(1)
 => #<Post:0x00007f3c969f5d88 id: 1, title: "hello", content: "world">
3.1.2 :003 > post.title
 => "hello"
3.1.2 :004 > post.content
 => "world"
3.1.2 :005 > post.content = 'rails'
 => "rails"
3.1.2 :006 > post.save
 => true
3.1.2 :007 > Post.all
  Post Load (0.5ms)  SELECT "posts".* FROM "posts"
 =>
[#<Post:0x00007fef9797af48 id: 1, title: "hello", content: "rails">]
#+end_src

| 類別/實體方法 | 說明                   |
|---------------+------------------------|
| ::count       | 回傳資料筆數           |
| ::find        | 用主鍵找，回傳Post物件 |
| ::all         | 回傳Post物件陣列       |
| #save         | 將物件回寫到資料表     |
| #destroy      | 刪除資料               |


**** 5-2-4 CRUD操作
+ Create - 新增
#+begin_src bash
# 使用 #create
post = Post.create title: 'hello', content: 'world'

# 使用 #new 與 #save
post = Post.new # 僅創造物件,不會寫入資料庫
post.title = 'hello'
post.content = 'world'
post.save # 將物件回寫到資料庫
#+end_src

+ Read - 檢索
#+begin_src bash
posts = Post.all    # 取得所有文章
post = Post.first   # 取得第一篇文章
post = Post.find(1) # 取得主鍵為1的文章

# 尋找標題是 hello 的文章
post = Post.find_by(title: 'hello')

# 尋找所有標題是 hello 的文章，並按照新增 id 降冪排序
posts = Post.where(name: 'hello').order('id DESC')
#+end_src

+ Update - 更新
#+begin_src bash
# 使用 #save
post = Post.find(1)
post.title = 'new title'
post.save # 回寫到資料庫

# 使用 #update
post = Post.find_by(title: 'new title')
post.update(title: 'new new title')

# 更新所有資料
Post.update_all genre: 'life'

# 局部更新所有資料，例如把所有分類為 rails 的文章改為 ruby on rails
Post.where(genre: 'rails').update_all(genre: 'ruby on rails')
#+end_src

+ 刪除
#+begin_src bash
# 刪除單筆資料
post = Post.find_by(title: 'new new title')
post.destroy

# 刪除所有資料
Post.destroy_all
#+end_src


**** 5-2-5 設定資料庫

  Rails預設的資料庫使用SQLite,若要換到別的資料庫,可以在Config/database.yml
做設定。

#+begin_src
default: &default
  adapter: sqlite3
  pool: <%= ENV.fetch("RAILS_MAX_THREADS") { 5 } %>
  timeout: 5000

development:
  <<: *default
  database: db/development.sqlite3

test:
  <<: *default
  database: db/test.sqlite3

production:
  <<: *default
  database: db/production.sqlite3
#+end_src

可用的設定:

| 設定     | 功能                                         |
|----------+----------------------------------------------|
| adapter  | adapter gem,例如mysql2,sqllite3,postgresql等 |
| host     | 主機                                         |
| database | 資料庫名稱                                   |
| encoding | 資料庫編碼                                   |
| timeout  | 連線逾時                                     |
| pool     | 連線數                                       |
| username | 登入帳號                                     |
| password | 登入密碼                                     |

資料庫連線的是由adapter gem 提供統一的介面.對一個rails網站抽換別種資料庫時,
只要修改config/database.yml adapter部份即可.

#+begin_src bash
rails s -e production
#+end_src

或者使用RAILS_ENV環境變數:
#+begin_src bash
RAILS_ENV=production rails s
#+end_src

以下是一個MySQL設定的範例:
#+begin_src
development:
  adapter: mysql
  encoding: utf8
  database: blog_development
  pool: 5
  username: root
  password:
  socket: /tmp/mysql.sock
#+end_src


*** 5-3 資料庫遷移

**** 5-3-1 新增遷移檔

#+begin_src
$ rails g migration modify_posts
      invoke   active_record
      create      db/migrate/20141209134930_modify_posts.rb
#+end_src

編輯剛剛產生的檔案,新增一個整數欄位view_count到posts表:

#+begin_src ruby
# db/migrate/20141209134930_modify_posts.rb
class ModifyPosts < ActiveRecord::Migration
  def change
    add_column :posts, :view_count, :integer
  end
end
#+end_src

#+begin_src
$ bin/rake db:migrate
== TIMESTAMP ModifyPosts: migrating =======================
-- add_column(:posts, :view_count, :integer)
  -> 0.0031s
== TIMESTAMP ModifyPosts: migrated (0.0032s) ==============
#+end_src

#+begin_src
$bin/rails dbconsole
SQLite version 3.37.2 2022-01-06 13:25:41
Enter ".help" for usage hints.
sqlite> .schema posts
CREATE TABLE IF NOT EXISTS "posts"
 ("id" integer NOT NULL PRIMARY KEY,
 "title" text DEFAULT NULL,
 "content" text DEFAULT NULL,
 "view_count" integer);
#+end_src

#+begin_src
sqlite> .tables
posts                 schema_migrations
sqlite> .schema schema_migrations
CREATE TABLE IF NOT EXISTS "schema_migrations"
   ("version" varchar NOT NULL PRIMARY KEY);
sqlite> SELECT * FROM schema_migrations;
20220914161418
#+end_src

#+begin_src
$ bin/rake db:migrate:status

database: db/development.sqlite3

 Status   Migration ID    Migration Name
--------------------------------------------------
   up     20220914161418  Modify posts
#+end_src

其中up表示該遷移檔已經執行過,下一次的bin/rake db:migrate並不會執行這個遷移。

我們再新增一個遷移檔,將view_count改為views:

#+begin_src
$ bin/rails g migration rename_view_count_in_posts
  invoke   active_record
  create     db/migrate/20220914162607_rename_view_count_in_posts.rb
#+end_src

用rename_column重命名:

#+begin_src ruby
# db/migrate/20220914162607_rename_view_count_in_posts.rb
class RenameViewCountInPosts < Activerecord::Migration
  def change
    rename_column :posts, :view_count, :views
  end
end
#+end_src

再遷移前,再看一次遷移進度中多了一個down的項目,表示目前有尚未執行的遷移檔:

#+begin_src
$ bin/rake db:migrate:status

database: db/development.sqlite3

 Status   Migration ID    Migration Name
--------------------------------------------------
   up     20220914161418  Modify posts
 down     20220914162312  Add view count in posts
#+end_src

再遷移一次

#+begin_src
$ bin/rake db:migrate
== TIMESTAMP RenameViewCountInPosts: migrating =======================
-- rename_column(:posts, :view_count, :views)
  -> 0.0106s
== TIMESTAMP Renameviewcountinposts: migrated (0.0107s) ==============
#+end_src

狀態顯示已經沒有任何的擱置的遷移檔:

#+begin_src
$ bin/rake db:migrate:status

database: db/development.sqlite3

 Status   Migration ID    Migration Name
--------------------------------------------------
   up     20220914161418  Modify posts
   up     20220914162312  Add view count in posts
   up     20220914162607  Rename view count in posts
#+end_src


**** 5-3-2 版本回滾

若發現遷移的schema不如預期,可以用bin/rake db:rollback回滾到最後一個遷移檔。
以此例可以從輸出訊息看到原本的view又被改回了view_count:

#+begin_src
$ bin/rake db:rollback
== TIMESTAMP RenameViewCountInPosts: reverting =======================
-- rename_column(:posts, :view_count, :views)
  -> 0.0117s
== TIMESTAMP Renameviewcountinposts: reverted (0.0146s) ==============
#+end_src

可以加上STEP環境變數來控制回滾幾個版本,例如:

#+begin_src
$ STEP=3 bin/rake db:rollback
#+end_src


**** 5-3-3 遷移指令

| 指令                                     | 說明                                |
|------------------------------------------+-------------------------------------|
| add_column(table, column, type)          | 新增欄                              |
| add_index(table, column)                 | 新增索引,會以table_column_index命名 |
| add_timestamps(table)                    | 新增created_at和updated_at欄        |
| change_column(table, column, type)       | 修改欄                              |
| create_table(table)                      | 新增表                              |
| drop_table(table)                        | 刪除表                              |
| remove_column(table, column)             | 刪除欄                              |
| remove_index(table, column)              | 刪除索引                            |
| remove_timestamps(table)                 | 刪除created_at與updated_at欄        |
| rename_column(table, old_name, new_name) | 重新命名欄                          |
| rename_index(table, old_name, new_name)  | 重新命名索引                        |
| rename_table(table, new_name)            | 重新命名表                          |

#+begin_src
# 使該欄位在資料庫不可是NULL,且預設為0
add_column :posts, :views, :integer, null: false, default:0
#+end_src


**** 5-3-4 change,up與down

上述提到資料庫遷移的管理方式,是藉由多個有序遷移檔的變更與回滾兩個部份的程式碼來控制schema版本。
而rails遷移檔的使用,則是將這兩部份的程式碼分別寫在#up和#down兩個方法中。事實上,在posts表
新增view_count欄位的遷移檔可以改寫如下:

#+begin_src ruby
# db/migrate/20141209134930_modify_posts.rb
class ModifyPosts < ActiveRecord::Migration
  # def change
  #  add_column :posts, :view_count, :integer
  # end

  # 等同於以下寫法
  def up
    add_column :posts, :view_count, :integer
  end

  def down
    remove_column :posts, :view_count
  end
end
#+end_src

這也是rails早期版本的寫法,#change是rails後期加入的新功能。有些回滾是可以透過變更的內容去推測出來的。

可被rails自動回滾的指令包括: add_column, add_index, add_timestamps, create_table, create_join_table,
remove_timestamps, rename_column, rename_index, rename_table。


**** 5-3-5 Model產生器

#+begin_src
$ bin/rails generate model NAME [field[:type] [:index] ...]
#+end_src

| 參數  | 說明                                  |
|-------+---------------------------------------|
| NAME  | model名稱,單數型態;蛇形或駱駝命行皆可 |
| field | 資料表的欄位名稱                      |
| type  | 資料型態,預設是string                 |
| index | 該欄位是否建立索引                    |

支援的資料型態:

| 資料型態    | 說明                                       |
|-------------+--------------------------------------------|
| primary_key | 主鍵                                       |
| string      | 短字串(255)                                |
| text        | 長字串                                     |
| integer     | 整數                                       |
| float       | 浮點數                                     |
| decimal     | 高精浮點數                                 |
| datetime    | 時間日期(字串)                             |
| timestamp   | UNIX時間(數字)                             |
| time        | 時間                                       |
| date        | 日期                                       |
| binary      | 二進位資料                                 |
| boolean     | 布林值                                     |
| json        | JSON字串,PostgreSQL專有                    |
| hstore      | 類似Ruby的Hash,只能使用一層;Postgresql專有 |

#+begin_src
$ bin/rails g model user name email about:text
    invoke  active_record
    create      db/migrate/20141211091418_create_users.rb
    create      app/models/user.rb
#+end_src

產生遷移檔並不會改變資料庫,需要再遷移一次:

#+begin_src
$ bin/rake db:migrate
== TIMESTAMP CreateUsers: migrating =======================
-- create_table(:users)
  -> 0.0035s
== TIMESTAMP CreateUsers: migrated (0.0035s) ==============
#+end_src

接著進入rails console,除了Post之外,已有User可使用:

#+begin_src ruby
User.count # => 0
user = User.create name: 'tony', email: 'tony@5xruby.tw', about: '嘉義人'
user.id    # => 1
User.count # => 1
user.name  # => "tony"
#+end_src


* Memo

#+begin_src
#+end_src
