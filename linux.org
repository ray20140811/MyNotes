* Git

** [[https://backlog.com/git-tutorial/tw/][連猴子都能懂的Git入門指南]]

*** Git的基本介紹


*** 教學1 開始使用Git

**** 初始設定

 Git的設定會被記錄在用戶的目錄首頁下的.gitconfig檔案裡。

 #+begin_src

 $ git config --global user.name "<使用者名字>"

 $ git config --global user.email "<電子信箱>"

 #+end_src

 可以為Git的命令設定別名，例如：「checkout」可以省略為「co」來執行。

 #+begin_src

 $ git config --global alias.co checkout

 #+end_src

 在Windows使用主控台（Git Bash）的話，含有中文的檔名會顯示為 "\346\226\260\350\246..."添加以下的設定，讓含有中文的檔名可以正確顯示。

 #+begin_src

 $ git config --global core.quotepath off

 #+end_src

 在提交訊息時要使用中文的話，不要使用 -m 參數，要用外部編輯器來輸入

 #+begin_src

 git config --global core.editor "emacs"

 #+end_src


**** 新建數據庫

在本地端建立新的數據庫。建立一個名稱為「tutorial」的空目錄，把它放在Git的管理之下。

#+begin_src

$ mkdir tutorial

$ cd tutorial

$ git init
Initialized empty Git repository in /Users/yourname/Desktop/tutorial/.git/

#+end_src


**** 提交檔案

首先在tutorial目錄裡新添一個名為「sample.txt」的文字檔案。請在檔案裡輸入以下的內容：

*連猴子都懂的Git命令*

#+begin_src

$ echo "連猴子都懂的Git命令" > sample.txt

#+end_src

在Git管理之下的目錄，可以使用status命令確認工作目錄與索引的狀態喔。

#+begin_src

$ git status

#+end_src

執行status命令確認tutorial目錄的狀態。

#+begin_src

$ git status
# On branch master
#
# Initial commit
#
# Untracked files:
#   (use "git add <file>..." to include in what will be committed)
#
#     sample.txt
nothing added to commit but untracked files present (use "git add" to track)

#+end_src

要將檔案加入到索引，可以使用add <file>命令。<file>是指向要加入索引的檔案。若要指向多個檔案，可用空白鍵將檔案們分開。

#+begin_src

$ git add sample.txt
$ git status
# On branch master
#
# Initial commit
#
# Changes to be committed:
#   (use "git rm --cached <file>..." to unstage)
#
#     new file:   sample.txt
#

#+end_src

#+begin_src

$ git commit -m "first commit"
[master (root-commit) 116a286] first commit
 0 files changed, 0 insertions(+), 0 deletions(-)
 create mode 100644 sample.txt

$ git status
# On branch master
nothing to commit (working directory clean)

#+end_src

#+begin_src

$ git log
commit ac56e474afbbe1eab9ebce5b3ab48ac4c73ad60e
Author: eguchi <eguchi@nulab.co.jp>
Date:   Thu Jul 12 18:00:21 2012 +0900

    first commit

#+end_src

安裝git的同時也會安裝gitk工具。可以用圖形化介面確認歷史提交記錄。

#+begin_src

$ gitk

#+end_src


*** 共享數據庫

**** Push到遠端數據庫

***** Push(推送)

為了將本地端數據庫的修改歷史共享到遠程數據庫，必須上​​傳本地端數據庫中儲存的修改歷史。

為此，需要在Git執行Push(推送)操作。執行Push之後，本地端的修改歷史會被上傳到遠端數據庫。遠端數據庫的修改歷史就會和本地端數據庫的修改歷史保持同步。

***** Clone(複製)

要下載遠端數據庫需要進行複製（Clone）的操作。

執行複製後，可以把遠端數據庫裡的內容全部下載下來，之後您可以在另一台機器的本地數據庫上進行操作。

***** Pull(拉取)

欲同步遠端數據庫以更新本地端數據庫，請使用Pull(拉取)。

執行pull之後，會從遠端數據庫下載最新的修改歷史，將其同步到自己的本地端數據庫。

*** 教學2 共享數據庫

**** 建立遠端數據庫

#+begin_src

$ mkdir tutorial-bare

$ cd tutorial-bare

$ git --bare init

#+end_src

**** Push到遠端數據庫

#+begin_src

$ git remote add <name> <url>

$ git remote add origin https://[your_space_id].backlog.jp/git/[your_project_key]/tutorial.git
#+end_src

#+begin_src

$ git push <repository> <refspec>...

#+end_src

#+begin_src

$ git push -u origin master
Username: <用戶名>
Password: <密碼>
Counting objects: 3, done.
Writing objects: 100% (3/3), 245 bytes, done.
Total 3 (delta 0), reused 0 (delta 0)
To https://nulab.backlog.jp/git/BLG/tutorial.git
 * [new branch]      master -> master

#+end_src

#+begin_src
#+end_src

**** 複製遠端數據庫

#+begin_src

$ cd ..

$ git clone tutorial-bare tutorial

$ cd tutorial

#+end_src

若要確認是否作業成功，請到複製的「tutorial2」目錄裡，查看sample.txt有沒有包含以下內容：

連猴子都懂的Git命令

#+begin_src

$ cd ..

$ git clone tutorial-bare tutorial2

$ cd tutorial2

#+end_src


**** 在複製的本地端數據庫執行Push

*tutorial2的操作*

首先，在上一頁複製（Clone）數據庫目錄裡的sample.txt，增加以下粗體字的部分後再提交。

連猴子都懂的Git命令
add 修改加入書籤

$ git add sample.txt
$ git commit -m "添加add的說明"
[master 1ef5c8c] 添加add的說明
 1 files changed, 1 insertions(+), 1 deletions(-)



教學2 共享數據庫
在複製的本地端數據庫執行push

讓我們來試試看在複製的本地端數據庫執行push吧。
選擇您使用的電腦系統
選擇主控台
主控台

tutorial2的操作
首先，在上一頁複製（Clone）數據庫目錄裡的sample.txt，增加以下粗體字的部分後再提交。

連猴子都懂的Git命令
add 修改加入書籤

$ git add sample.txt
$ git commit -m "添加add的說明"
[master 1ef5c8c] 添加add的說明
 1 files changed, 1 insertions(+), 1 deletions(-)

tutorial2的操作
接下來，push這次的修改到遠端數據庫。

在複製的數據庫裡執行push命令時，您可以省略數據庫和分支的名稱。

$ git push
Username: <用戶名>
Password: <密碼>
Counting objects: 5, done.
Delta compression using up to 4 threads.
Compressing objects: 100% (2/2), done.
Writing objects: 100% (3/3), 351 bytes, done.
Total 3 (delta 0), reused 0 (delta 0)
To https://nulab.backlog.jp/git/BLG/tutorial.git
   486789c..1ef5c8c  master -> master

請打開貝格樂的Git頁面。您可以看到push內容已被添加到「最近的更新」了。


**** 從遠端數據庫執行Pull

在tutorial的操作
請執行以下的命令。

$ git pull origin master
Username: <用戶名>
Password: <密碼>
From https://nulab.backlog.jp/git/BLG/tutorial
 * branch            master     -> FETCH_HEAD
Updating ac56e47..3da09c1
Fast-forward
 sample.txt |    1 +
 1 files changed, 1 insertions(+), 0 deletions(-)

已經更新sample.txt檔案的內容。

在tutorial的操作
使用log命令確認歷史記錄。

$ git log
commit 3da09c1134a41f2bee854a413916e4ebcae7318d
Author: eguchi <eguchi@nulab.co.jp>
Date:   Thu Jul 12 18:02:45 2012 +0900

    添加add的說明

commit ac56e474afbbe1eab9ebce5b3ab48ac4c73ad60e
Author: eguchi <eguchi@nulab.co.jp>
Date:   Thu Jul 12 18:00:21 2012 +0900

    first commit

在「tutorial2」新添加的提交現在已被列表在這個數據庫的歷史記錄上。

在tutorial的操作
打開sample.txt檔案確認內容。

連猴子都懂的Git命令
add 修改加入書籤

我們可以看到內容已添加至「add ：修改加入索引」中。

**** 合併修改記錄

您上次的push到執行下一次的push的期間，如果有其他人push更新了遠端數據庫，而您沒有更新您的本地端數據庫，那麼您的push會被拒絕。

這個時候，需要進行合併操作導入其他人的修改歷史，不然push都會被拒絕喔。若沒有合併直接覆蓋歷史記錄的話，其他人push的修改內容（如圖提交C）會消失。

**** 解決衝突

上一頁已經講解過了，Git執行合併會自動合併修改的部分，但也有不能自動合併的時候。

如果遠端數據庫和本地端數據庫的同一個地方都發生了修改的情況下（例：檔案中同一行的地方）。
這時，因為Git不能自動判斷要導入那一個修改內容於是就會發生錯誤。

發生衝突的地方，Git會修改檔案的內容如下圖顯示。所以衝突的地方需要手動修改喔。

發生衝突的案例

如下圖所示，修改好所有衝突的地方之後，執行提交會提交衝突的合併訊息的提交內容。

*** 教學3 合併修改記錄

**** 製造衝突

在tutorial的操作
首先在打開tutorial目錄的sample.txt，修改成以下的內容再提交。

連猴子都懂的Git命令
add 修改加入索引
commit 記錄索引的狀態

$ git add sample.txt
$ git commit -m "添加commit的說明"
[master 95f15c9] 添加commit的說明
 1 files changed, 1 insertions(+), 0 deletions(-)

在tutorial2的操作
接著打開tutorial2目錄的sample.txt，修改成以下的內容再提交。

連猴子都懂的Git命令
add 修改加入索引
pull 取得遠端數據庫的內容

$ git add sample.txt
$ git commit -m "添加pull的說明"
[master 4c01823] 添加pull的說明
 1 files changed, 1 insertions(+), 0 deletions(-)

在tutorial2的操作
直接從tutorial2 push內容到遠端數據庫。

$ git push
Username: <用戶名>
Password: <密碼>
Counting objects: 5, done.
Delta compression using up to 4 threads.
Compressing objects: 100% (2/2), done.
Writing objects: 100% (3/3), 391 bytes, done.
Total 3 (delta 0), reused 0 (delta 0)
To https://nulab.backlog.jp/git/BLG/tutorial.git
   3da09c1..4c01823  master -> master

現在，遠端數據庫的第三行即為「pull 取得遠端數據庫的內容」啦。

在tutorial的操作
接下來，從tutorial push提交到遠端數據庫。

$ git push
Username: <用戶名>
Password: <密碼>
To https://nulab.backlog.jp/git/BLG/tutorial.git
 ! [rejected]        master -> master (non-fast-forward)
error: failed to push some refs to 'https://nulab.backlog.jp/git/BLG/tutorial.git'
To prevent you from losing history, non-fast-forward updates were rejected
Merge the remote changes (e.g. 'git pull') before pushing again.  See the
'Note about fast-forwards' section of 'git push --help' for details.

看到吧，發生錯誤了，push被拒絕(rejected)了。

**** 解決衝突

在tutorial的操作
執行以下的命令。

$ git pull origin master
Username: <用戶名>
Password: <密碼>
remote: Counting objects: 5, done.
remote: Compressing objects: 100% (2/2), done.
remote: Total 3 (delta 0), reused 0 (delta 0)
Unpacking objects: 100% (3/3), done.
From https://nulab.backlog.jp/git/BLG/tutorial
 * branch            master     -> FETCH_HEAD
Auto-merging sample.txt
CONFLICT (content): Merge conflict in sample.txt
Automatic merge failed; fix conflicts and then commit the result.

接著，系統會出現合併時發生衝突的警告訊息。

在tutorial的操作
打開sample.txt檔案確認內容，Git將用標示行顯示內容發生衝突的地方，如下圖：

連猴子都懂的Git命令
add 修改加入索引
<<<<<<< HEAD
commit 記錄索引的狀態
=======
pull 取得遠端數據庫的內容
>>>>>>> 4c0182374230cd6eaa93b30049ef2386264fe12a

在tutorial的操作

請修改

將衝突的地方進行修改，導入兩方的修改，刪除多餘的標示行。請參考下圖：

連猴子都懂的Git命令
add 修改加入索引
commit 記錄索引的狀態
pull 取得遠端數據庫的內容

在tutorial的操作
當修改完內容，解決了檔案的衝突，則需要執行提交。

$ git add sample.txt
$ git commit -m "合併"
[master d845b81] 合併

這樣就完成了從遠端數據庫導入最新的修改內容了。

在tutorial的操作
我們可以使用log命令來確認數據庫的修改歷史。若加入 --graph 參數可以圖表方式顯示分支歷史。加入--oneline 簡化輸出訊息，以簡潔方式呈現。

$ git log --graph --oneline
*   d845b81 合併
|\
| * 4c01823 添加pull的說明
* | 95f15c9 添加commit的說明
|/
* 3da09c1 添加add的說明
* ac56e47 first commit

這表示兩個修改歷史已經成功合併且建立了新的合併提交。

我們現在可以放心地push變更到遠端數據庫，不用擔心會產生任何衝突。

** 為你自己學 Git

*** 使用者設定

#+BEGIN_SRC bash

$ git config --global user.name "Eddie Kao"

$ git config --global user.email "eddie@5xruby.tw"

$ git config --list
user.name=Eddie Kao
user.email=eddie@5xruby.tw
#+END_SRC

*** 設定檔的位置
檔案: ~/.gitconfig

*** 【狀況題】可以每個專案設定不同的作者嗎?

#+BEGIN_SRC bash

$ git config --local user.name Sherly

$ git config --local user.email sherly@5xruby.tw

#+END_SRC

*** 更換編輯器
#+BEGIN_SRC bash

$ git config --global core.editor emacs

#+END_SRC

*** Git 裡設定一些「縮寫」

#+BEGIN_SRC bash

$ git config --global alias.co checkout

$ git config --global alias.br branch

$ git config --global alias.st status

#+END_SRC

可以再加一些參數進去 ex: git log --oneline --graph
#+BEGIN_SRC bash

$ git config --global alias.l "log --oneline --graph"

$ git config --global alias.ls 'log --graph --pretty=format:"%h <%an> %ar %s"'

$ git log --oneline --graph

$ git log --graph --pretty=format:"%h <%an> %ar %s"

#+END_SRC

*** 新增、初始 Repository

#+BEGIN_SRC bash

$ mkdir git-practice# 建立 git-practice 目錄

$ cd git-practice# 切換至 git-practice 目錄

$ git init# 初始化這個目錄,讓 Git 對這個目錄開始進行版控
Initialized empty Git repository in /private/tmp/git-practice/.git/

#+END_SRC

#+BEGIN_SRC bash

$ git status
On branch master
Initial commit
nothing to commit (create/copy files and use "git add" to track)

#+END_SRC

#+BEGIN_SRC bash

$ echo "hello, git" > welcome.html

$ git status
On branch master

No commits yet

Untracked files:
  (use "git add <file>..." to include in what will be committed)
	welcome.html

nothing added to commit but untracked files present (use "git add" to track)

#+END_SRC

一次只加一個檔案

#+BEGIN_SRC bash

$ git add welcome.html

$ git status
On branch master

No commits yet

Changes to be committed:
  (use "git rm --cached <file>..." to unstage)
	new file:   welcome.html

#+END_SRC

可以使用萬用字元,可把所有附檔名是 html 的檔案全部都加到暫存區。

#+BEGIN_SRC bash

$ git add *.html

#+END_SRC

如果想要一口氣把全部的檔案加到暫存區,可直接使用 --all 參數:

#+BEGIN_SRC bash

$ git add --all

#+END_SRC

*** 【狀況題】如果在git add之後又修改了那個檔案的內容?

1. 你新增了一個檔案叫做 abc.txt 。
2. 然後,執行 git add abc.txt 把檔案加至暫存區。
3. 接著編輯 abc.txt 檔案。

#+BEGIN_SRC bash

$ git status
On branch master
Changes to be committed:
	(use "git reset HEAD <file>..." to unstage)

		new file:	abc.txt

Changes not staged for commit:
	(use "git add <file>..." to update what will be committed)
	(use "git checkout -- <file>..." to discard changes in working directory)

		modified:	abc.txt

#+END_SRC

*** 【冷知識】"--all" 跟 "." 參數有什麼不一樣?
1. Git 版本
在 git 1.x版的時候

| 使用參數 | 新增檔案 | 修改檔案 | 刪除檔案 |
| --all    | O        | O        | O        |
| .        | O        | O        | X        |

在 git 2.x版的時候

| 使用參數 | 新增檔案 | 修改檔案 | 刪除檔案 |
| --all    | O        | O        | O        |
| .        | O        | O        | O        |

2. 執行指令時候的目錄位置
git add . 這個指令會把目前當下這個目錄,以及它的子目錄、子子目錄、子子子目
錄...裡的異動全部加到暫存區,但在這個目錄的以外的就不歸它管了。

git add --all 指令
就沒這個問題,這個指令不管在專案的哪一層目錄執行,效果都是一樣的,在這個專案裡所有
的異動都會被加至暫存區。

答案會跟所使用的 Git 版本不同以及執行指令時的目錄而有所差異。

*** 把暫存區的內容提交到倉庫裡存檔

#+BEGIN_SRC bash

$ git commit -m "init commit"
[master (root-commit) dfccf0c] init commit
 1 file changed, 1 insertion(+)
 create mode 100644 welcome.html

#+END_SRC

*** 【冷知識】一定要有東⻄才能 Commit 嗎?

只要加上 --allow-empty 參數,沒東⻄也是可以 Commit 的:

#+BEGIN_SRC bash

$ git commit --allow-empty -m "空的"
[master 76a5b84] 空的

$ git commit --allow-empty -m "空的"
[master f4f568c] 空的

$ git commit --allow-empty -m "空的"
[master 7653117] 空的

#+END_SRC

*** 工作區、暫存區與儲存庫

1. git add 指令把檔案從工作目錄移至暫存區(或索引)。
2. git commit 指令把暫存區的內容移至儲存庫。

**** 一定要二段式嗎?

#+BEGIN_SRC bash

$ git commit -a -m "update content"

#+END_SRC

*** 檢視紀錄

#+BEGIN_SRC bash

$ git log
commit 82603ed32d877a1cc1c022ed48d2c69b2bc892cd (HEAD -> master)
Author: Ray Kuo <ray20140811@gmail.com>
Date:   Sat Sep 17 01:38:26 2022 +0800

    create index page

commit 36f407ffdf5d63a3b5cdd36d92c3e665033b1aa4
Author: Ray Kuo <ray20140811@gmail.com>
Date:   Fri Sep 16 16:58:21 2022 +0800

    init commit

#+END_SRC

*** git log參數
#+BEGIN_SRC bash

$ git log --oneline --graph
\* 82603ed (HEAD -> master) create index page
\* 36f407f init commit

#+END_SRC

*** 【狀況題】我想要找某個人或某些人的 Commit...

**** 找一位叫做 Sherly 的作者的 Commit

#+BEGIN_SRC bash

$ git log --oneline --author="Sherly"
930feb3 add pig
51d54ff add lion and tiger

#+END_SRC

**** 可以用|來查詢兩個人的紀錄

#+BEGIN_SRC bash

$ git log --oneline --author="Sherly\|Eddie"

#+END_SRC

*** 【狀況題】我想要找 Commit 訊息裡面有在罵髒話的

#+BEGIN_SRC bash

$ git log --oneline --grep="WTF"

#+END_SRC

#+BEGIN_SRC bash
#+END_SRC


** 你知道的 Git 和我知道的是同一件事嗎？
   https://www.youtube.com/watch?v=j72-2ktvZV4


** 你知道 Git 是怎麼一回事嗎
   https://www.youtube.com/watch?v=LgTf7m5B0xA
   - git add . 和 git add --all 這兩個指令有什麽不一樣？

   在 git 1.x版的時候
   | 使用參數 | 新增檔案 | 修改檔案 | 刪除檔案 |
   | -------  | -------  | -------  | ------   |
   | --all    | O        | O        | O        |
   | .        | O        | O        | X        |

   在 git 2.x版的時候
   | 使用參數 | 新增檔案 | 修改檔案 | 刪除檔案 |
   | -------- | -------- | -------- | -------- |
   | --all    | O        | O        | O        |
   | .        | O        | O        | O        |

   git add --all指令不管在專案的哪一層目錄執行都有效果


#+BEGIN_SRC bash
#+END_SRC

#+BEGIN_SRC bash
#+END_SRC


* Emacs

** Emacs筆記

| M-g g | goto-line     | 跳到指定行號      |
| M-d   | kill-word     | delete one word   |
| C-w   | kill-region   | delete one line   |
| M-w   | easy-kill     | copy              |
| C-y   | yank          | paste             |
| M-%   | query-replace | query and replace |


** [[https://orgmode.org][Org Mode]]


** [[https://www.cnblogs.com/Open_Source/archive/2011/07/17/2108747.html][Org-mode 简明手册]]


* rails

** Ruby on Rails自習手冊

*** 5-2 Active Record

| 物件導向         | 關聯式資料庫 |
|------------------+--------------|
| 類別 (class)     | 表 (table)   |
| 物件 (object)    | 列 (row)     |
| 屬性 (attribute) | 欄 (column)  |

**** 5-2-1 命名慣例

| 物件導向   | 關聯式資料庫                          |
|------------+---------------------------------------|
| 資料表     | 複數單字、蛇形命名法，例如 book_clubs |
| Model 類別 | 單數單字、駱駝命名法，例如 BookClub   |

| 類別     | 資料表     |
|----------+------------|
| Post     | posts      |
| LineItem | line_items |
| Deer     | deers      |
| Mouse    | mice       |
| Person   | people     |


**** 5-2-2 rails dbconsole
#+begin_src bash
$ bin/rails dbconsole
#+end_src

#+begin_src SQL
CREATE TABLE posts(
  id INTEGER PRIMARY KEY,
  title TEXT,
  content TEXT
);
#+end_src

#+begin_src ruby
# app/models/post.rb
class Post < ActiveRecord::Base
end
#+end_src


**** 5-2-3 rails console

#+begin_src bash
$ bin/rails console
Loading development environment (Rails 7.0.4)
3.1.2 :001 > Post.create title: 'hello', content: 'world'
=> #<Post id: 1, title: "hello", content: "world">
#+end_src

#+begin_src bash
$ bin/rails dbconsole
sqlite> select * from posts;
1|hello|world
#+end_src

#+begin_src bash
$ bin/rails console
Loading development environment (Rails 7.0.4)
3.1.2 :001 > Post.count
 => 1
3.1.2 :002 > post = Post.find(1)
 => #<Post:0x00007f3c969f5d88 id: 1, title: "hello", content: "world">
3.1.2 :003 > post.title
 => "hello"
3.1.2 :004 > post.content
 => "world"
3.1.2 :005 > post.content = 'rails'
 => "rails"
3.1.2 :006 > post.save
 => true
3.1.2 :007 > Post.all
  Post Load (0.5ms)  SELECT "posts".* FROM "posts"
 =>
[#<Post:0x00007fef9797af48 id: 1, title: "hello", content: "rails">]
#+end_src

| 類別/實體方法 | 說明                   |
|---------------+------------------------|
| ::count       | 回傳資料筆數           |
| ::find        | 用主鍵找，回傳Post物件 |
| ::all         | 回傳Post物件陣列       |
| #save         | 將物件回寫到資料表     |
| #destroy      | 刪除資料               |


**** 5-2-4 CRUD操作
+ Create - 新增
#+begin_src bash
# 使用 #create
post = Post.create title: 'hello', content: 'world'

# 使用 #new 與 #save
post = Post.new # 僅創造物件,不會寫入資料庫
post.title = 'hello'
post.content = 'world'
post.save # 將物件回寫到資料庫
#+end_src

+ Read - 檢索
#+begin_src bash
posts = Post.all    # 取得所有文章
post = Post.first   # 取得第一篇文章
post = Post.find(1) # 取得主鍵為1的文章

# 尋找標題是 hello 的文章
post = Post.find_by(title: 'hello')

# 尋找所有標題是 hello 的文章，並按照新增 id 降冪排序
posts = Post.where(name: 'hello').order('id DESC')
#+end_src

+ Update - 更新
#+begin_src bash
# 使用 #save
post = Post.find(1)
post.title = 'new title'
post.save # 回寫到資料庫

# 使用 #update
post = Post.find_by(title: 'new title')
post.update(title: 'new new title')

# 更新所有資料
Post.update_all genre: 'life'

# 局部更新所有資料，例如把所有分類為 rails 的文章改為 ruby on rails
Post.where(genre: 'rails').update_all(genre: 'ruby on rails')
#+end_src

+ 刪除
#+begin_src bash
# 刪除單筆資料
post = Post.find_by(title: 'new new title')
post.destroy

# 刪除所有資料
Post.destroy_all
#+end_src


**** 5-2-5 設定資料庫

  Rails預設的資料庫使用SQLite,若要換到別的資料庫,可以在Config/database.yml
做設定。

#+begin_src
default: &default
  adapter: sqlite3
  pool: <%= ENV.fetch("RAILS_MAX_THREADS") { 5 } %>
  timeout: 5000

development:
  <<: *default
  database: db/development.sqlite3

test:
  <<: *default
  database: db/test.sqlite3

production:
  <<: *default
  database: db/production.sqlite3
#+end_src

可用的設定:

| 設定     | 功能                                         |
|----------+----------------------------------------------|
| adapter  | adapter gem,例如mysql2,sqllite3,postgresql等 |
| host     | 主機                                         |
| database | 資料庫名稱                                   |
| encoding | 資料庫編碼                                   |
| timeout  | 連線逾時                                     |
| pool     | 連線數                                       |
| username | 登入帳號                                     |
| password | 登入密碼                                     |

資料庫連線的是由adapter gem 提供統一的介面.對一個rails網站抽換別種資料庫時,
只要修改config/database.yml adapter部份即可.

#+begin_src bash
rails s -e production
#+end_src

或者使用RAILS_ENV環境變數:
#+begin_src bash
RAILS_ENV=production rails s
#+end_src

以下是一個MySQL設定的範例:
#+begin_src
development:
  adapter: mysql
  encoding: utf8
  database: blog_development
  pool: 5
  username: root
  password:
  socket: /tmp/mysql.sock
#+end_src


*** 5-3 資料庫遷移

**** 5-3-1 新增遷移檔

#+begin_src
$ rails g migration modify_posts
      invoke   active_record
      create      db/migrate/20141209134930_modify_posts.rb
#+end_src

編輯剛剛產生的檔案,新增一個整數欄位view_count到posts表:

#+begin_src ruby
# db/migrate/20141209134930_modify_posts.rb
class ModifyPosts < ActiveRecord::Migration
  def change
    add_column :posts, :view_count, :integer
  end
end
#+end_src

#+begin_src
$ bin/rake db:migrate
== TIMESTAMP ModifyPosts: migrating =======================
-- add_column(:posts, :view_count, :integer)
  -> 0.0031s
== TIMESTAMP ModifyPosts: migrated (0.0032s) ==============
#+end_src

#+begin_src
$bin/rails dbconsole
SQLite version 3.37.2 2022-01-06 13:25:41
Enter ".help" for usage hints.
sqlite> .schema posts
CREATE TABLE IF NOT EXISTS "posts"
 ("id" integer NOT NULL PRIMARY KEY,
 "title" text DEFAULT NULL,
 "content" text DEFAULT NULL,
 "view_count" integer);
#+end_src

#+begin_src
sqlite> .tables
posts                 schema_migrations
sqlite> .schema schema_migrations
CREATE TABLE IF NOT EXISTS "schema_migrations"
   ("version" varchar NOT NULL PRIMARY KEY);
sqlite> SELECT * FROM schema_migrations;
20220914161418
#+end_src

#+begin_src
$ bin/rake db:migrate:status

database: db/development.sqlite3

 Status   Migration ID    Migration Name
--------------------------------------------------
   up     20220914161418  Modify posts
#+end_src

其中up表示該遷移檔已經執行過,下一次的bin/rake db:migrate並不會執行這個遷移。

我們再新增一個遷移檔,將view_count改為views:

#+begin_src
$ bin/rails g migration rename_view_count_in_posts
  invoke   active_record
  create     db/migrate/20220914162607_rename_view_count_in_posts.rb
#+end_src

用rename_column重命名:

#+begin_src ruby
# db/migrate/20220914162607_rename_view_count_in_posts.rb
class RenameViewCountInPosts < Activerecord::Migration
  def change
    rename_column :posts, :view_count, :views
  end
end
#+end_src

再遷移前,再看一次遷移進度中多了一個down的項目,表示目前有尚未執行的遷移檔:

#+begin_src
$ bin/rake db:migrate:status

database: db/development.sqlite3

 Status   Migration ID    Migration Name
--------------------------------------------------
   up     20220914161418  Modify posts
 down     20220914162312  Add view count in posts
#+end_src

再遷移一次

#+begin_src
$ bin/rake db:migrate
== TIMESTAMP RenameViewCountInPosts: migrating =======================
-- rename_column(:posts, :view_count, :views)
  -> 0.0106s
== TIMESTAMP Renameviewcountinposts: migrated (0.0107s) ==============
#+end_src

狀態顯示已經沒有任何的擱置的遷移檔:

#+begin_src
$ bin/rake db:migrate:status

database: db/development.sqlite3

 Status   Migration ID    Migration Name
--------------------------------------------------
   up     20220914161418  Modify posts
   up     20220914162312  Add view count in posts
   up     20220914162607  Rename view count in posts
#+end_src


**** 5-3-2 版本回滾

若發現遷移的schema不如預期,可以用bin/rake db:rollback回滾到最後一個遷移檔。
以此例可以從輸出訊息看到原本的view又被改回了view_count:

#+begin_src
$ bin/rake db:rollback
== TIMESTAMP RenameViewCountInPosts: reverting =======================
-- rename_column(:posts, :view_count, :views)
  -> 0.0117s
== TIMESTAMP Renameviewcountinposts: reverted (0.0146s) ==============
#+end_src

可以加上STEP環境變數來控制回滾幾個版本,例如:

#+begin_src
$ STEP=3 bin/rake db:rollback
#+end_src


**** 5-3-3 遷移指令

| 指令                                     | 說明                                |
|------------------------------------------+-------------------------------------|
| add_column(table, column, type)          | 新增欄                              |
| add_index(table, column)                 | 新增索引,會以table_column_index命名 |
| add_timestamps(table)                    | 新增created_at和updated_at欄        |
| change_column(table, column, type)       | 修改欄                              |
| create_table(table)                      | 新增表                              |
| drop_table(table)                        | 刪除表                              |
| remove_column(table, column)             | 刪除欄                              |
| remove_index(table, column)              | 刪除索引                            |
| remove_timestamps(table)                 | 刪除created_at與updated_at欄        |
| rename_column(table, old_name, new_name) | 重新命名欄                          |
| rename_index(table, old_name, new_name)  | 重新命名索引                        |
| rename_table(table, new_name)            | 重新命名表                          |

#+begin_src
# 使該欄位在資料庫不可是NULL,且預設為0
add_column :posts, :views, :integer, null: false, default:0
#+end_src


**** 5-3-4 change,up與down

上述提到資料庫遷移的管理方式,是藉由多個有序遷移檔的變更與回滾兩個部份的程式碼來控制schema版本。
而rails遷移檔的使用,則是將這兩部份的程式碼分別寫在#up和#down兩個方法中。事實上,在posts表
新增view_count欄位的遷移檔可以改寫如下:

#+begin_src ruby
# db/migrate/20141209134930_modify_posts.rb
class ModifyPosts < ActiveRecord::Migration
  # def change
  #  add_column :posts, :view_count, :integer
  # end

  # 等同於以下寫法
  def up
    add_column :posts, :view_count, :integer
  end

  def down
    remove_column :posts, :view_count
  end
end
#+end_src

這也是rails早期版本的寫法,#change是rails後期加入的新功能。有些回滾是可以透過變更的內容去推測出來的。

可被rails自動回滾的指令包括: add_column, add_index, add_timestamps, create_table, create_join_table,
remove_timestamps, rename_column, rename_index, rename_table。


**** 5-3-5 Model產生器

#+begin_src
$ bin/rails generate model NAME [field[:type] [:index] ...]
#+end_src

| 參數  | 說明                                  |
|-------+---------------------------------------|
| NAME  | model名稱,單數型態;蛇形或駱駝命行皆可 |
| field | 資料表的欄位名稱                      |
| type  | 資料型態,預設是string                 |
| index | 該欄位是否建立索引                    |

支援的資料型態:

| 資料型態    | 說明                                       |
|-------------+--------------------------------------------|
| primary_key | 主鍵                                       |
| string      | 短字串(255)                                |
| text        | 長字串                                     |
| integer     | 整數                                       |
| float       | 浮點數                                     |
| decimal     | 高精浮點數                                 |
| datetime    | 時間日期(字串)                             |
| timestamp   | UNIX時間(數字)                             |
| time        | 時間                                       |
| date        | 日期                                       |
| binary      | 二進位資料                                 |
| boolean     | 布林值                                     |
| json        | JSON字串,PostgreSQL專有                    |
| hstore      | 類似Ruby的Hash,只能使用一層;Postgresql專有 |

#+begin_src
$ bin/rails g model user name email about:text
    invoke  active_record
    create      db/migrate/20141211091418_create_users.rb
    create      app/models/user.rb
#+end_src

產生遷移檔並不會改變資料庫,需要再遷移一次:

#+begin_src
$ bin/rake db:migrate
== TIMESTAMP CreateUsers: migrating =======================
-- create_table(:users)
  -> 0.0035s
== TIMESTAMP CreateUsers: migrated (0.0035s) ==============
#+end_src

接著進入rails console,除了Post之外,已有User可使用:

#+begin_src ruby
User.count # => 0
user = User.create name: 'tony', email: 'tony@5xruby.tw', about: '嘉義人'
user.id    # => 1
User.count # => 1
user.name  # => "tony"
#+end_src


* Memo

#+begin_src
#+end_src
